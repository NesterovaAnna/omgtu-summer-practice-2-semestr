#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

// здесь писать код

#!csharp

using System;
using System.Threading;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;

// ConcurrentQueue
(int, int, int) TestConcurrentQueue()
{
    ConcurrentQueue<int> concurrentQueue = new ConcurrentQueue<int>();
    Stopwatch  time = new Stopwatch();
    Stopwatch time1 = new Stopwatch();
    Stopwatch time2 = new Stopwatch();
    ManualResetEvent resetEvent = new ManualResetEvent(false);

    Thread thread1 = new Thread(() =>
    {
        resetEvent.WaitOne();
        time1.Start();
        for (int i = 0; i < 1000000; i++)
        {
            concurrentQueue.Enqueue(i);
        }
        time1.Stop();
    });

    Thread thread2 = new Thread(() =>
    {
        resetEvent.WaitOne();
        int result;
        time2.Start();
        for (int i = 0; i < 1000000; i++)
        {
            while (!concurrentQueue.TryDequeue(out result)) { }
        }
        time2.Stop();
    });
    thread1.Start();
    thread2.Start();
    resetEvent.Set();
    time.Start();
    thread1.Join();
    thread2.Join();
    time.Stop();
    return ((int)time.ElapsedMilliseconds, (int)time1.ElapsedMilliseconds, (int)time2.ElapsedMilliseconds);
}

// BlockingCollection
(int, int, int) TestBlockingCollection()
{
    BlockingCollection<int> blockingCollection = new BlockingCollection<int>();
    Stopwatch time = new Stopwatch();
    Stopwatch time1 = new Stopwatch();
    Stopwatch time2 = new Stopwatch();
    ManualResetEvent resetEvent = new ManualResetEvent(false);

    Thread thread1 = new Thread(() =>
    {
        resetEvent.WaitOne();
        time1.Start();
        for (int i = 0; i < 1000000; i++)
        {
            blockingCollection.Add(i);
        }
        time1.Stop();
        blockingCollection.CompleteAdding();
    });

    Thread thread2 = new Thread(() =>
    {
        resetEvent.WaitOne();
        time2.Start();
        while (!blockingCollection.IsCompleted)
        {
            if (blockingCollection.TryTake(out _)) { }
        }
        time2.Stop();
    });
    thread1.Start();
    thread2.Start();
    resetEvent.Set();
    time.Start();
    thread1.Join();
    thread2.Join();
    time.Stop();
    return ((int)time.ElapsedMilliseconds, (int)time1.ElapsedMilliseconds, (int)time2.ElapsedMilliseconds);
}

// Queue
(int, int, int) TestQueue()
{
    Queue<int> queue = new Queue<int>();
    Stopwatch time = new Stopwatch();
    Stopwatch time1 = new Stopwatch();
    Stopwatch time2 = new Stopwatch();
    time.Start();
    time1.Start();
    for (int i = 0; i < 1000000; i++) 
    { 
        queue.Enqueue(i); 
    }
    time1.Stop();
    time2.Start();
    for (int i = 0; i < 1000000; i++) 
    { 
        queue.Dequeue(); 
    }
    time2.Stop();
    time.Stop();
    return ((int)time.ElapsedMilliseconds, (int)time1.ElapsedMilliseconds, (int)time2.ElapsedMilliseconds);
}

(int[], int[]) Test(Func<(int, int, int)> testMethod)
{
    int[] res = new int[10];
    int[] ite = new int[10];
    for (int i = 1; i < 11; i++)
    {
        res[i - 1] = testMethod().Item1;
        ite[i - 1] = i;
    }
    return (ite, res);
}

#!csharp

#r "nuget:ScottPlot, 5.0.35"
using Microsoft.DotNet.Interactive.Formatting;

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(800, 400)), HtmlFormatter.MimeType);
(int[] dataX1,int[] dataY1) = Test(TestConcurrentQueue);
(int[] dataX2,int[] dataY2) = Test(TestBlockingCollection);
(int[] dataX3,int[] dataY3) = Test(TestQueue);

ScottPlot.Plot plt = new();
plt.Add.Scatter(dataX1, dataY1);
plt.Add.Scatter(dataX2, dataY2);
plt.Add.Scatter(dataX3, dataY3);

Console.WriteLine($"ConcurrentQueue: {dataY1.Average()}\nBlockingCollection: {dataY2.Average()}\nQueue: {dataY3.Average()}");

plt

#!markdown

## Вывод

Наиболее эффективная потоко-безопасная коллекция - ConcurrentQueue 

В сравнение с обычной очередью Queue, потоко-безопасная коллекция ConcurrentQueue эффуктивнее на 16%
